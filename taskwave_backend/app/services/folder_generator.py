import io
import zipfile
from typing import List, Dict
from datetime import datetime

# ParsedSlot은 app/services/timetable.py에 정의되어 있으므로,
# 여기서는 필요한 필드만 가진 간단한 Dict 타입으로 가정하거나,
# 실제 ParsedSlot을 임포트해야 합니다.
# 여기서는 편의상 Dict로 처리합니다.
# from app.services.timetable import ParsedSlot # 실제 사용 시 주석 해제

def build_zip_bytes(slots: List[Dict]) -> bytes:
    """
    파싱된 시간표 슬롯 목록을 바탕으로 가상의 폴더 구조를 가진 ZIP 파일을 생성합니다.
    """
    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED, False) as zf:
        # 각 슬롯을 기반으로 폴더 및 파일 생성
        for slot in slots:
            subject = slot.get("subject", "미정 과목").replace("/'", "_")
            weekday = slot.get("weekday_ko", "미정 요일")
            start_time = slot.get("start", "00:00").replace(":", "_")
            end_time = slot.get("end", "00:00").replace(":", "_")

            # 예: 과목명/요일/시작시간-종료시간.txt
            folder_path = f"{subject}/{weekday}"
            file_name = f"{start_time}-{end_time}.txt"
            full_path = f"{folder_path}/{file_name}"

            file_content = f"과목: {subject}\n"
            file_content += f"요일: {weekday}\n"
            file_content += f"시간: {slot.get("start")} - {slot.get("end")}\n"
            file_content += f"교수: {slot.get("professor", "N/A")}\n"
            file_content += f"장소: {slot.get("location", "N/A")}\n"
            file_content += f"\n[원본 텍스트]\n{slot.get("raw_text", "")}"

            # ZIP 파일에 추가
            zf.writestr(full_path, file_content.encode("utf-8"))

        # 메타데이터 파일 추가 (선택 사항)
        meta_content = f"Generated by Taskwave\n"
        meta_content += f"Generation Date: {datetime.now().isoformat()}\n"
        meta_content += f"Total Slots: {len(slots)}\n"
        zf.writestr("metadata.txt", meta_content.encode("utf-8"))

    zip_buffer.seek(0)
    return zip_buffer.getvalue()
